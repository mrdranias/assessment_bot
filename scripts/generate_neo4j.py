#!/usr/bin/env python3
"""
generate_neo4j_init.py
Generates an init.cypher script for initializing Neo4j with ADL/IADL assessments,
based on clinical_assessment_data.py.
"""
import sys
sys.path.append("..")
from clinical_assessment_data import get_iadl_questions, get_adl_questions
import datetime

def domain_nodes(questions):
    seen = set()
    nodes = []
    for q in questions:
        dkey = (q['domain'], q['assessment_type'])
        if dkey not in seen:
            nodes.append(
                f"CREATE (:Domain {{name: '{q['domain']}', category: '{q['assessment_type']}', description: '{q['assessment_type']} - {q['domain'].replace('_',' ').title()}'}});"
            )
            seen.add(dkey)
    return nodes

def question_nodes(questions):
    nodes = []
    for q in questions:
        nodes.append(
            f"CREATE (:Question {{id: '{q['code']}', code: '{q['code']}', domain: '{q['domain']}', sequence: {q['sequence']}, text: '{q['text'].replace('\'','\\\'')}', description: '{q['description'].replace('\'','\\\'')}', assessment_type: '{q['assessment_type']}'}});"
        )
    return nodes

def domain_question_rels(questions):
    rels = []
    for q in questions:
        rels.append(
            f"MATCH (d:Domain {{name: '{q['domain']}', category: '{q['assessment_type']}'}}), (q:Question {{id: '{q['code']}'}}) CREATE (d)-[:HAS_QUESTION]->(q);"
        )
    return rels

def answer_nodes_and_rels(questions):
    cypher = []
    for q in questions:
        for idx, ans in enumerate(q['answers']):
            aid = f"{q['code']}_OPT_{ans['order']}"
            cypher.append(
                f"CREATE (a_{aid}:Answer {{id: '{aid}', text: '{ans['text'].replace('\'','\\\'')}', clinical_score: {ans['clinical_score']}, answer_order: {ans['order']}}});"
            )
            cypher.append(
                f"MATCH (q:Question {{id: '{q['code']}'}}), (a_{aid}:Answer {{id: '{aid}'}}) CREATE (q)-[:HAS_OPTION]->(a_{aid});"
            )
    return cypher

def sequential_links(questions):
    cypher = []
    for i in range(len(questions) - 1):
        curr_code = questions[i]['code']
        next_code = questions[i+1]['code']
        cypher.append(
            f"MATCH (q1:Question {{id: '{curr_code}'}}), (q2:Question {{id: '{next_code}'}}) CREATE (q1)-[:NEXT_QUESTION]->(q2);"
        )
    return cypher

def main():
    filename = "init.cypher"
    now = datetime.datetime.now().strftime("%Y-%m-%d %H:%M")
    lines = []
    lines.append(f"// Generated by generate_neo4j_init.py on {now}")
    lines.append("// DO NOT EDIT MANUALLY\n")
    lines.append("// === Constraints & Indexes ===")
    lines.append("CREATE CONSTRAINT domain_name_unique IF NOT EXISTS FOR (d:Domain) REQUIRE d.name IS UNIQUE;")
    lines.append("CREATE CONSTRAINT question_code_unique IF NOT EXISTS FOR (q:Question) REQUIRE q.code IS UNIQUE;")
    lines.append("CREATE CONSTRAINT answer_id_unique IF NOT EXISTS FOR (a:Answer) REQUIRE a.id IS UNIQUE;")
    lines.append("CREATE INDEX question_sequence IF NOT EXISTS FOR (q:Question) ON (q.sequence);")
    lines.append("\n// === Clear existing data ===")
    lines.append("MATCH (n) DETACH DELETE n;\n")

    # Get questions, IADL then ADL for flow
    iadl = get_iadl_questions()
    adl = get_adl_questions()
    all_questions = iadl + adl

    # Domains
    lines.append("// === Create Domains ===")
    lines += domain_nodes(all_questions)
    lines.append("")

    # Questions
    lines.append("// === Create Questions ===")
    lines += question_nodes(all_questions)
    lines.append("")

    # Domain-Question relationships
    lines.append("// === Create Domain -> Question Relationships ===")
    lines += domain_question_rels(all_questions)
    lines.append("")

    # Answers and HAS_OPTION relationships
    lines.append("// === Create Answer nodes and HAS_OPTION Relationships ===")
    lines += answer_nodes_and_rels(all_questions)
    lines.append("")

    # Sequential flow: IADL â†’ ADL
    lines.append("// === Create Sequential Question Flow (IADL then ADL) ===")
    lines += sequential_links(all_questions)
    lines.append("")

    # Flow control (assessment start/end)
    lines.append("// === Assessment Start/End Nodes and Flow ===")
    lines.append("CREATE (start:AssessmentFlow {id: 'start', type: 'introduction', message: \"Let's begin your daily living abilities assessment. Please answer the following questions.\"});")
    lines.append("CREATE (end:AssessmentFlow {id: 'completion', type: 'completion', message: \"Thank you for completing the assessment.\"});")
    # First and last question
    lines.append(f"MATCH (start:AssessmentFlow {{id: 'start'}}), (first:Question {{id: '{all_questions[0]['code']}'}}) CREATE (start)-[:LEADS_TO]->(first);")
    lines.append(f"MATCH (last:Question {{id: '{all_questions[-1]['code']}'}}), (end:AssessmentFlow {{id: 'completion'}}) CREATE (last)-[:LEADS_TO]->(end);")

    # Write to file
    with open(filename, 'w', encoding='utf-8') as f:
        f.write('\n'.join(lines))

    print(f"init.cypher generated with {len(lines)} lines.")

if __name__ == "__main__":
    main()
